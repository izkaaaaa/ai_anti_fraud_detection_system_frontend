# 实时检测接口对接文档

## 📋 概述

本文档介绍实时音视频检测的WebSocket接口，用于前端实时发送音频流和视频流进行AI反诈检测。

---

## 🔗 WebSocket连接

### 接口地址

```
ws://localhost:8000/api/detection/ws/{user_id}/{call_id}?token={jwt_token}
```

### 参数说明

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `user_id` | int | 是 | 用户ID |
| `call_id` | int | 是 | 通话记录ID |
| `token` | string | 是 | JWT认证Token（Query参数） |

### 连接示例

```javascript
// 1. 获取JWT Token（从登录接口获取）
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";

// 2. 建立WebSocket连接
const userId = 1;
const callId = 123;
const ws = new WebSocket(
  `ws://localhost:8000/api/detection/ws/${userId}/${callId}?token=${token}`
);

// 3. 监听连接状态
ws.onopen = () => {
  console.log('✅ WebSocket连接成功');
};

ws.onerror = (error) => {
  console.error('❌ WebSocket连接失败:', error);
};

ws.onclose = () => {
  console.log('🔌 WebSocket连接已关闭');
};
```

---

## 📤 发送数据格式

### 1. 发送音频数据

**格式：**

```json
{
  "type": "audio",
  "data": "base64编码的音频数据"
}
```

**示例代码：**

```javascript
// 录制音频（每3秒一段）
async function sendAudio() {
  // 1. 录制音频（WAV/MP3格式）
  const audioBlob = await recordAudio(3000); // 录制3秒
  
  // 2. 转为ArrayBuffer
  const arrayBuffer = await audioBlob.arrayBuffer();
  
  // 3. 转为Base64
  const base64Audio = btoa(
    String.fromCharCode(...new Uint8Array(arrayBuffer))
  );
  
  // 4. 发送到后端
  ws.send(JSON.stringify({
    type: 'audio',
    data: base64Audio
  }));
}

// 每3秒发送一次
setInterval(sendAudio, 3000);
```

**音频要求：**
- 格式：WAV、MP3、M4A、OGG
- 时长：建议3秒一段
- 采样率：16000Hz或更高
- 编码：Base64

---

### 2. 发送视频数据

**格式：**

```json
{
  "type": "video",
  "data": "base64编码的视频帧（JPEG图片）"
}
```

**示例代码：**

```javascript
// 捕获视频帧（每秒1帧）
function sendVideoFrame() {
  // 1. 从video元素捕获当前帧
  const video = document.querySelector('video');
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // 2. 绘制到canvas
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0);
  
  // 3. 转为Base64（JPEG格式）
  const base64Frame = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
  
  // 4. 发送到后端
  ws.send(JSON.stringify({
    type: 'video',
    data: base64Frame
  }));
}

// 每秒发送1帧
setInterval(sendVideoFrame, 1000);
```

**视频要求：**
- 格式：JPEG图片（单帧）
- 频率：每秒1帧
- 分辨率：建议640x480或更高
- 编码：Base64
- 质量：0.7-0.9（JPEG质量）

---

### 3. 心跳维持（可选）

**格式：**

```json
{
  "type": "heartbeat"
}
```

**示例代码：**

```javascript
// 每30秒发送一次心跳
setInterval(() => {
  ws.send(JSON.stringify({
    type: 'heartbeat'
  }));
}, 30000);
```

---

## 📥 接收数据格式

### 1. ACK确认消息

后端收到数据后会立即返回ACK确认。

**音频ACK：**

```json
{
  "type": "ack",
  "msg_type": "audio",
  "timestamp": "2026-02-18T10:00:00"
}
```

**视频ACK：**

```json
{
  "type": "ack",
  "msg_type": "video",
  "status": "buffering",
  "timestamp": "2026-02-18T10:00:00"
}
```

**status说明：**
- `buffering` - 正在积攒帧（还没满10帧）
- `ready` - 缓冲区满了，已投递检测任务

**心跳ACK：**

```json
{
  "type": "heartbeat_ack",
  "timestamp": "2026-02-18T10:00:00"
}
```

---

### 2. 检测结果消息

检测完成后，后端会推送检测结果。

**音频检测结果：**

```json
{
  "type": "detection_result",
  "detection_type": "语音",
  "is_risk": true,
  "confidence": 0.95,
  "message": "⚠️ 检测到AI合成语音，置信度95%",
  "timestamp": "2026-02-18T10:00:03"
}
```

**视频检测结果：**

```json
{
  "type": "detection_result",
  "detection_type": "视频",
  "is_risk": true,
  "confidence": 0.88,
  "message": "⚠️ 检测到AI换脸，置信度88%",
  "timestamp": "2026-02-18T10:00:14"
}
```

**字段说明：**
- `type` - 消息类型（固定为`detection_result`）
- `detection_type` - 检测类型（`语音`或`视频`）
- `is_risk` - 是否有风险（`true`/`false`）
- `confidence` - 置信度（0-1之间）
- `message` - 提示消息
- `timestamp` - 检测时间

---

### 3. 防御升级消息

检测到风险时，后端会推送防御升级指令。

```json
{
  "type": "control",
  "action": "upgrade_level",
  "target_level": 2,
  "reason": "检测到AI合成语音",
  "config": {
    "ui_message": "⚠️ 警告：检测到AI合成语音，请提高警惕！",
    "show_full_screen_warning": true,
    "enable_call_recording": true
  }
}
```

**字段说明：**
- `action` - 动作类型（`upgrade_level`）
- `target_level` - 目标防御等级（1-3）
- `reason` - 升级原因
- `config.ui_message` - 显示给用户的消息
- `config.show_full_screen_warning` - 是否显示全屏警告
- `config.enable_call_recording` - 是否开启录音

---

## 💻 完整示例代码

```javascript
class RealtimeDetection {
  constructor(userId, callId, token) {
    this.userId = userId;
    this.callId = callId;
    this.token = token;
    this.ws = null;
  }
  
  // 建立连接
  connect() {
    const url = `ws://localhost:8000/api/detection/ws/${this.userId}/${this.callId}?token=${this.token}`;
    this.ws = new WebSocket(url);
    
    this.ws.onopen = () => {
      console.log('✅ 连接成功');
      this.startDetection();
    };
    
    this.ws.onmessage = (event) => {
      this.handleMessage(JSON.parse(event.data));
    };
    
    this.ws.onerror = (error) => {
      console.error('❌ 连接错误:', error);
    };
    
    this.ws.onclose = () => {
      console.log('🔌 连接关闭');
    };
  }
  
  // 开始检测
  startDetection() {
    // 每3秒发送音频
    this.audioInterval = setInterval(() => {
      this.sendAudio();
    }, 3000);
    
    // 每秒发送视频帧
    this.videoInterval = setInterval(() => {
      this.sendVideoFrame();
    }, 1000);
    
    // 每30秒发送心跳
    this.heartbeatInterval = setInterval(() => {
      this.sendHeartbeat();
    }, 30000);
  }
  
  // 发送音频
  async sendAudio() {
    try {
      const audioBlob = await this.recordAudio(3000);
      const arrayBuffer = await audioBlob.arrayBuffer();
      const base64Audio = btoa(
        String.fromCharCode(...new Uint8Array(arrayBuffer))
      );
      
      this.ws.send(JSON.stringify({
        type: 'audio',
        data: base64Audio
      }));
      
      console.log('📤 已发送音频');
    } catch (error) {
      console.error('音频发送失败:', error);
    }
  }
  
  // 发送视频帧
  sendVideoFrame() {
    try {
      const video = document.querySelector('video');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0);
      
      const base64Frame = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
      
      this.ws.send(JSON.stringify({
        type: 'video',
        data: base64Frame
      }));
      
      console.log('📤 已发送视频帧');
    } catch (error) {
      console.error('视频帧发送失败:', error);
    }
  }
  
  // 发送心跳
  sendHeartbeat() {
    this.ws.send(JSON.stringify({
      type: 'heartbeat'
    }));
    console.log('💓 已发送心跳');
  }
  
  // 处理接收到的消息
  handleMessage(message) {
    switch (message.type) {
      case 'ack':
        console.log(`✅ ACK: ${message.msg_type}`);
        break;
        
      case 'heartbeat_ack':
        console.log('💓 心跳响应');
        break;
        
      case 'detection_result':
        this.handleDetectionResult(message);
        break;
        
      case 'control':
        this.handleControlMessage(message);
        break;
        
      default:
        console.log('收到消息:', message);
    }
  }
  
  // 处理检测结果
  handleDetectionResult(result) {
    console.log(`🔍 检测结果: ${result.detection_type}`);
    console.log(`   风险: ${result.is_risk ? '是' : '否'}`);
    console.log(`   置信度: ${(result.confidence * 100).toFixed(1)}%`);
    console.log(`   消息: ${result.message}`);
    
    if (result.is_risk) {
      // 显示警告
      this.showWarning(result.message);
    }
  }
  
  // 处理控制消息
  handleControlMessage(control) {
    if (control.action === 'upgrade_level') {
      console.log(`⚠️ 防御升级到Level ${control.target_level}`);
      console.log(`   原因: ${control.reason}`);
      
      // 显示全屏警告
      if (control.config.show_full_screen_warning) {
        this.showFullScreenWarning(control.config.ui_message);
      }
    }
  }
  
  // 显示警告
  showWarning(message) {
    alert(message);
  }
  
  // 显示全屏警告
  showFullScreenWarning(message) {
    // 实现全屏警告UI
    console.log('🚨 全屏警告:', message);
  }
  
  // 录制音频（需要实现）
  async recordAudio(duration) {
    // 实现音频录制逻辑
    // 返回Blob对象
  }
  
  // 停止检测
  stop() {
    clearInterval(this.audioInterval);
    clearInterval(this.videoInterval);
    clearInterval(this.heartbeatInterval);
    
    if (this.ws) {
      this.ws.close();
    }
    
    console.log('🛑 已停止检测');
  }
}

// 使用示例
const detection = new RealtimeDetection(1, 123, 'your_jwt_token');
detection.connect();

// 停止检测
// detection.stop();
```

---

## ⏱️ 时间线说明

### 音频检测时间线

```
T=0s:   前端发送音频
T=0.01s: 后端返回ACK
T=3s:   后端返回检测结果（AI模型推理完成）
```

**延迟：约3秒**

---

### 视频检测时间线

```
T=0s:   前端发送第1帧
T=0.01s: 后端返回ACK (status: buffering)
T=1s:   前端发送第2帧
...
T=9s:   前端发送第10帧
T=9.01s: 后端返回ACK (status: ready)
T=14s:  后端返回检测结果（积攒10帧+AI推理）
```

**延迟：约14秒（积攒10帧需要10秒 + 推理4秒）**

---

## 🔧 注意事项

### 1. 数据发送频率

- **音频**：每3秒发送一段
- **视频**：每秒发送1帧
- **心跳**：每30秒发送一次（可选）

### 2. 数据格式要求

- 音频必须是Base64编码
- 视频帧必须是JPEG格式的Base64编码
- JSON格式必须正确

### 3. 连接管理

- 检测到连接断开时，应自动重连
- 重连时需要重新传入JWT Token
- 建议实现指数退避重连策略

### 4. 错误处理

```javascript
ws.onerror = (error) => {
  console.error('WebSocket错误:', error);
  // 实现重连逻辑
};

ws.onclose = (event) => {
  if (event.code !== 1000) {
    console.error('非正常关闭:', event.code, event.reason);
    // 实现重连逻辑
  }
};
```

### 5. 性能优化

- 视频帧建议压缩（JPEG质量0.7-0.8）
- 音频建议使用压缩格式（MP3、OGG）
- 避免发送过大的数据（单次<1MB）

---

## 🐛 常见问题

### Q1: WebSocket连接失败

**原因：**
- JWT Token无效或过期
- 后端服务未启动
- 网络问题

**解决：**
```javascript
// 检查Token是否有效
console.log('Token:', token);

// 检查后端是否运行
// 访问 http://localhost:8000/docs 查看API文档
```

---

### Q2: 发送数据后没有收到ACK

**原因：**
- 数据格式错误
- Base64编码错误
- 网络延迟

**解决：**
```javascript
// 添加超时检测
setTimeout(() => {
  console.warn('⚠️ 3秒内未收到ACK');
}, 3000);
```

---

### Q3: 检测结果延迟很高

**原因：**
- 音频检测：约3秒（正常）
- 视频检测：约14秒（正常，需要积攒10帧）

**说明：**
这是正常的检测延迟，因为AI模型需要时间推理。

---

## 📞 技术支持

如有问题，请联系后端开发团队。

**后端接口文档：** http://localhost:8000/docs

**项目地址：** E:\wangtiao\AI-Anti-Fraud-Detection-System-API

---

## 📝 更新日志

- **2026-02-23**: 初始版本，支持音频和视频实时检测

